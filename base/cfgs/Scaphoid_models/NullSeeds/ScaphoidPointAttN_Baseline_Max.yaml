model_name: ScaphoidPointAttN

dataset : {
  train : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'train'}},
  val : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'val'}},
  test : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'test'}},
  # transforms : [
  #   'DecoupledDemeaning', 
  #   'DecoupledRandomRotation',
  #   'DecoupledRescale', # maybe never rotate GT such that network learns to rotate volar side back and then maybe also dorsal side
  # ],
  transform_with: 'volar',    # has no effect in this experiment because we use the same transforms for both sides
  reverse_transforms: 'no',    # 'for training' # 'for logging only'   # 'no'
  transforms : [
    'CoupledDemeaning', 
    'CoupledRandomRotation',
    'CoupledRescale', # maybe never rotate GT such that network learns to rotate volar side back and then maybe also dorsal side
  ]
}

# first test: do concat of volar and dorsal to have a baseline only with coupled transforms and only use volar for seeds
# second test: use two FEs and concat shape codes with only coupled transforms and only use volar for seeds
# third test: use two FEs and concat shape codes with Encoupled transforms and only use volar for seeds <- make it gradually harder (offset -> rotation etc.)


# concat volar+dorsal without any augmentation -> get shape code -> generate seeds using shape code and only volar points -> best possible outcome if volar and dorsal sides cannot be aligned
# two FEs (volar and dorsal) -> two shape codes -> generate seeds using both shape codes

# rotate volar side independent from gt and then reverse the rotation to get the gt using the saved transforms
# make network use dorsal side by encoding rotation of gt in dorsal side
# generate seeds using volar side. Register seeds to dorsal side using.
model : {
    NAME: ScaphoidPointAttN,
    num_points: 8192, # ToDo: Bestimme num_points
    arch: default_arch_max_null_seeds,
    available_building_blocks : {
      # feature_extractor: concat, # separate, mix
      
      
      feature_extractor: {type: 'FE', keys: [in, out], mode: 'pointattn'},
      feature_extractor_affil: {type: 'FE', keys: [in, out], mode: 'affil'},
      feature_extractor_intermediate: {type: 'FE', keys: [in, out], mode: 'FE-'}, # feature_extractor, but stops before compressing features into shape code
      feature_extractor_tnet: {type: 'FE', keys: [in, out], mode: 'TNet'}, 

      seed_attn_matcher: {type: 'SAM', keys: [in, seeds, out], mode: 'attn'}, # seed attention matcher that takes the features and the seeds and generates a shape code
      
      seed_generator: {type: 'SG', keys: [shape_code, out], mode: 'SG-'}, # seed_generator that only takes the shape code and generates seeds
      seed_generator_to_sparse: {type: 'SG', keys: [in, shape_code, out], mode: 'pointattn'},  # seed_generator that also adds the input points to the seeds and does fps to create sparse_pc
      
      point_generator: {type: 'PG', keys: [seeds, shape_code, out], mode: 'pointattn'},
      
      t_net_input: {type: 'TNet', keys: [in, out, K], mode: 'input'},
      t_net_features: {type: 'TNet', keys: [in, out, K], mode: 'features'},

      seeds_to_sparse_pc: {type: 'OP', keys: [in, out], mode: 'seeds_to_sparse_pc'},
      concat_2: {type: 'OP', keys: [in, out], mode: 'concat-dim-2'},
      concat_1: {type: 'OP', keys: [in, out], mode: 'concat-dim-1'},
      affil_enricher: {type: 'OP', keys: [in, out], mode: 'affil'},
      fps: {type: 'OP', keys: [in, out], mode: 'fps'},
    },
    available_archs: {
      default_arch_volar: [feature_extractor: {in: volar, out: shape_code_v}, seed_generator_to_sparse: {in: volar, shape_code: shape_code_v, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_v, out: points}],
      default_arch_dorsal: [feature_extractor: {in: dorsal, out: shape_code_d}, seed_generator_to_sparse: {in: dorsal, shape_code: shape_code_d, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_d, out: points}],
      default_arch_max: [concat_2: {in: [volar, dorsal], out: concat}, feature_extractor: {in: concat, out: shape_code_v_d}, seed_generator_to_sparse: {in: concat, shape_code: shape_code_v_d, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_v_d, out: points}],
      default_arch_max_v_in: [concat_2: {in: [volar, dorsal], out: concat}, feature_extractor: {in: concat, out: shape_code_v_d}, seed_generator_to_sparse: {in: volar, shape_code: shape_code_v_d, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_v_d, out: points}],
      default_arch_max_d_in: [concat_2: {in: [volar, dorsal], out: concat}, feature_extractor: {in: concat, out: shape_code_v_d}, seed_generator_to_sparse: {in: dorsal, shape_code: shape_code_v_d, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_v_d, out: points}],

      default_arch_max_null_seeds: [concat_2: {in: [volar, dorsal], out: concat}, feature_extractor: {in: concat, out: shape_code_v_d}, seed_generator: {shape_code: shape_code_v_d, out: sparse_pc}, point_generator: {seeds: sparse_pc, shape_code: shape_code_v_d, out: points}],

    
    }
}

optimizer : {
  type: AdamW,
  kwargs: {
  lr : 0.0001,
  weight_decay : 0.0005
}}

scheduler: {
  type: LambdaLR,
  kwargs: {
  decay_step: 21,
  lr_decay: 0.9,
  lowest_decay: 0.02  # min lr = lowest_decay * lr
}}

bnmscheduler: {
  type: Lambda,
  kwargs: {
  decay_step: 21,
  bn_decay: 0.5,
  bn_momentum: 0.9,
  lowest_decay: 0.01
}}

# test
save_vis: False


total_bs: 32
step_per_update : 1
max_epoch : 100

consider_metric: CDL1
