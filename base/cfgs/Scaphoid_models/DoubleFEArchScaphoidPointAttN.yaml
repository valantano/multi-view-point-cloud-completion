model_name: ScaphoidPointAttN

dataset : {
  train : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'train'}},
  val : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'val'}},
  test : { _base_: dataset_configs/ScaphoidDataset.yaml,
            others: {subset: 'test'}},
  transforms : [
    'DecoupledDemeaning', 
    'DecoupledRandomRotation',
    'DecoupledRescale', # maybe never rotate GT such that network learns to rotate volar side back and then maybe also dorsal side
  ],
  # transforms : [
  #   'CoupledDemeaning', 
  #   'CoupledRandomRotation',
  #   'CoupledRescale', # maybe never rotate GT such that network learns to rotate volar side back and then maybe also dorsal side
  # ]
            }

# first test: do concat of volar and dorsal to have a baseline only with coupled transforms and only use volar for seeds
# second test: use two FEs and concat shape codes with only coupled transforms and only use volar for seeds
# third test: use two FEs and concat shape codes with Encoupled transforms and only use volar for seeds <- make it gradually harder (offset -> rotation etc.)


# concat volar+dorsal without any augmentation -> get shape code -> generate seeds using shape code and only volar points -> best possible outcome if volar and dorsal sides cannot be aligned
# two FEs (volar and dorsal) -> two shape codes -> generate seeds using both shape codes

# rotate volar side independent from gt and then reverse the rotation to get the gt using the saved transforms
# make network use dorsal side by encoding rotation of gt in dorsal side
# generate seeds using volar side. Register seeds to dorsal side using.
model : {
    NAME: ScaphoidPointAttN,
    num_points: 8192, # ToDo: Bestimme num_points
    arch: double_fe_arch,
    available_building_blocks : {
      # feature_extractor: concat, # separate, mix
      feature_extractor_v: {input: 'volar', output: 'shape_code_v', mode: 'org'},
      feature_extractor_d: {input: 'dorsal', output: 'shape_code_d', mode: 'org'},
      feature_extractor_c: {input: 'concat', output: 'shape_code_c', mode: 'org'},
      feature_extractor_affil: {input: 'x_y_z_affiliation', output: 'shape_code_affil', mode: 'org'},   # takes merged points from volar and dorsal side with corresponding affiliation

      feature_extractors_seperate: {blocks: [feature_extractor_v, feature_extractor_d, concat_shape_code]},


      concat_shape_code: {input: [shape_code_v, shape_code_d], output: 'shape_code_v_d', mode: 'org'},


      seed_generator_v: {input: 'volar', shape_code: 'shape_code_v', output: 'seeds_v', mode: 'org'},
      seed_generator_d: {input: 'dorsal', shape_code: 'shape_code_d', output: 'seeds_d', mode: 'org'},
      seed_generator_c: {input: 'volar', shape_code: 'shape_code_c', output: 'seeds_c', mode: 'org'},    # if FE can do registration internally, then input still only volar or dorsal
      seed_generator_mix: {input: 'volar', shape_code: 'dorsal', output: 'seeds_mix', mode: 'org'},

      seed_generator_x: {input: 'volar', shape_code: 'shape_code_*', output: 'seeds_*', mode: 'org'},   # universal seed generator taking whatever input is available


      point_generator_v: {seeds: 'seeds_v', shape_code: 'shape_code_v', output: 'points', mode: 'org'},
      point_generator_x: {seeds: 'seeds_*', shape_code: 'shape_code_*', output: 'points', mode: 'org'}, # universal point generator taking whatever input is available
    },
    available_archs: {

      default_arch:         {FE: feature_extractor_v, SG: seed_generator_v, PG: point_generator_x},
      mix_arch:             {FE: feature_extractor_v, SG: seed_generator_mix, PG: point_generator_x},    # extrac features from volar side and match them on dorsal side in seed generation
      internal_reg_arch:    {FE: feature_extractor_c, SG: seed_generator_x, PG: point_generator_x},    # test if FE can do registration internally
      double_fe_arch:       {FE: feature_extractors_seperate, SG: seed_generator_x, PG: point_generator_x},    # test if two FEs can be used to generate seeds
      intertwined_fe_arch:  {FE: feature_extractor_intertwined, SG: seed_generator_v, PG: point_generator_x},
      affiliation_arch:     {FE: feature_extractor_affil, SG: seed_generator_x, PG: point_generator_x},    # test if affiliation can be used to generate seeds
    }
}

optimizer : {
  type: AdamW,
  kwargs: {
  lr : 0.0001,
  weight_decay : 0.0005
}}

scheduler: {
  type: LambdaLR,
  kwargs: {
  decay_step: 21,
  lr_decay: 0.9,
  lowest_decay: 0.02  # min lr = lowest_decay * lr
}}

bnmscheduler: {
  type: Lambda,
  kwargs: {
  decay_step: 21,
  bn_decay: 0.5,
  bn_momentum: 0.9,
  lowest_decay: 0.01
}}

# test
save_vis: False


total_bs: 24
step_per_update : 1
max_epoch : 100

consider_metric: CDL1
